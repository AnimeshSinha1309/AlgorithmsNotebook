#include "template.hpp"

struct node{int val,prior,size;node *l,*r;};typedef node* pnode;int sz(pnode t){return t?t->size:0;}void upd_sz(pnode t){if(t)t->size = sz(t->l)+1+sz(t->r);}void split(pnode t,pnode &l,pnode &r,int key){if(!t)l=r=NULL;else if(t->val<=key)split(t->r,t->r,r,key),l=t;else split(t->l,l,t->l,key),r=t;upd_sz(t);}void merge(pnode &t,pnode l,pnode r){if(!l || !r)t=l?l:r;else if(l->prior> r->prior)merge(l->r,l->r,r),t=l;else merge(r->l,l,r->l),t=r;upd_sz(t);}void insert(pnode &t,pnode it){if(!t) t=it;else if(it->prior>t->prior)split(t,it->l,it->r,it->val),t=it;else insert(t->val<it->val?t->r:t->l,it);upd_sz(t);}void erase(pnode &t,int key){if(!t)return;else if(t->val==key){pnode x=t;merge(t,t->l,t->r);free(x);}else erase(t->val<key?t->r:t->l,key);upd_sz(t);}void unite (pnode &t,pnode l, pnode r){if(!l||!r)return void(t=l?l:r);pnode lt,rt;if(l->prior<r->prior)swap(l,r);split(r,lt,rt,l->val);unite(l->l,l->l,lt);unite(l->r,l->r,rt);t=l;upd_sz(t);}pnode init(int val){pnode ret = (pnode)malloc(sizeof(node));ret->val=val;ret->size=1;ret->prior=rand();ret->l=ret->r=NULL;return ret;}insert(init(x),head);
// Interval Tree
struct node{int prior,size,val,sum,lazy;node *l,*r;};typedef node* pnode;int sz(pnode t){return t?t->size:0;}void upd_sz(pnode t){if(t)t->size=sz(t->l)+1+sz(t->r);}void lazy(pnode t){if(!t || !t->lazy)return;t->val+=t->lazy;t->sum+=t->lazy*sz(t);if(t->l)t->l->lazy+=t->lazy;if(t->r)t->r->lazy+=t->lazy;t->lazy=0;}void reset(pnode t){if(t)t->sum = t->val;//already propagated}void combine(pnode& t,pnode l,pnode r){3
if(!l || !r)return void(t = l?l:r);t->sum = l->sum + r->sum;}void operation(pnode t){if(!t)return;reset(t);lazy(t->l);lazy(t->r);combine(t,t->l,t);combine(t,t,t->r);}void split(pnode t,pnode &l,pnode &r,int pos,int add=0){if(!t)return void(l=r=NULL);lazy(t);int cpos=add+sz(t->l);if(cpos<=pos)split(t->r,t->r,r,pos,cpos+1),l=t;else split(t->l,l,t->l,pos,add),r=t;upd_sz(t);operation(t);}void merge(pnode &t,pnode l,pnode r){lazy(l);lazy(r);if(!l || !r) t = l?l:r;else if(l->prior>r->prior)merge(l->r,l->r,r),t=l;else merge(r->l,l,r->l),t=r;upd_sz(t);operation(t);}pnode init(int val){pnode ret=(pnode)malloc(sizeof(node));ret->prior=rand();ret->size=1;ret->val=val;ret->sum=val;ret->lazy=0;return ret;}int range_query(pnode t,int l,int r){pnode L,mid,R;split(t,L,mid,l-1);split(mid,t,R,r-l);/*note: r-l!*/int ans = t->sum;merge(mid,L,t);merge(t,mid,R);return ans;}void range_update(pnode t,int l,int r,int val){pnode L,mid,R;split(t,L,mid,l-1);split(mid,t,R,r-l);/*note: r-l!*/t->lazy+=val; merge(mid,L,t);merge(t,mid,R);}