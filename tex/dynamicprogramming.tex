\chapter{Dynamic Programming}

The focus of this chapter would be to enlist all the optimizations to a DP possible and types of recurrences solvable using them.



\section{Matrix Exponentiation}


\begin{example}{}
\textbf{Number of ways to construct an array starting in X, and ending in Y, with no two adjacent elements are the same.}
\begin{equation*}
    dp[i] = \begin{bmatrix} dp[i][\text{CLASH}] \\ dp[i][\text{CLEAN}] \end{bmatrix}
    = \begin{bmatrix} 0 & 1 \\ k-1 & k-2 \end{bmatrix} \times dp[i-1]
\end{equation*}
\end{example}


\section{Bitmasks}


\subsection{Classical Bitmasks}

The idea is trivial, we take each bitmask to represent an arbitrary subset of any given set.


\subsection{Sum over Subsets}

We want to sum for each mask, some given function (as an array) for all it's submasks.
We can take each mask to start off, and then go down a series of all it's subsets in decreasing order of value of mask, the algorithm for this will be $j = (j - 1)\;\&\;mask$, initially $j_0 = mask$.

Time complexity is the following:
\begin{equation}
    T(n) = \sum_{k=0}^{n-1} C^n_k 2^k = 3^k 
\end{equation}

\begin{example}
    Find the number of ways in the given array of $10^6$ numbers
\end{example}