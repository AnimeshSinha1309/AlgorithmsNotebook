{
    "Default contents of C++ file": {
        "prefix": "$cppdefault",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "typedef long long ll;",
            "typedef vector<long long> vll;",
            "typedef pair<long long, long long> pll;",
            "typedef vector<vector<long long>> mll;",
            "typedef vector<pair<long long, long long>> vpl;",
            "typedef long double ld;",
            "typedef vector<long double> vld;",
            "typedef vector<vector<long double>> mld;",
            "typedef vector<bool> vbl;",
            "typedef vector<vector<bool>> mbl;",
            "#define minimize(a, b) (a = min(a, b))",
            "#define maximize(a, b) (a = max(a, b))",
            "const long long MOD = 1e9 + 7;",
            "",
            "template <typename Type>",
            "istream &operator>>(istream &in, vector<Type> &vec) {",
            "   ll n = vec.size();",
            "   for (int i = 0; i < n; i++)",
            "       in >> vec[i];",
            "   return in;",
            "}",
            "template <typename Type>",
            "ostream &operator<<(ostream &out, vector<Type> &vec) {",
            "    for (auto val : vec)",
            "        out << val << \" \";",
            "    out << endl;",
            "    return out;",
            "}",
            "",
            "int main() {",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "    cout.tie(nullptr);",
            "    $0",
            "}"
        ],
        "description": "Default contents of a C++ file"
    },
    "Graph Class": {
        "prefix": "$ds-graph",
        "body": [
            "class Graph {",
            "    public:",
            "     enum NodeColor { VISITED, VISITING, UNVISITED };",
            "     struct Node {",
            "         int index;",
            "         vpl adjacent;",
            "         NodeColor color = UNVISITED;",
            "     };",
            "     vector<Node> list;",
            "     int n;",
            "     Graph(int n) {",
            "         list.resize(n);",
            "         for (int i = 0; i < n; i++)",
            "             list[i].index = i;",
            "         this->n = n;",
            "     }",
            "     void add_edge(int u, int v, long long w = 1) {",
            "         list[u].adjacent.emplace_back(v, w);",
            "         list[v].adjacent.emplace_back(u, w);",
            "     }",
            " ",
            "     pair<vll, vll> dijkstra(vll from) {",
            "         vll dist(n, INT64_MAX), parent(n, INT32_MAX);",
            "         priority_queue<pll, vpl, greater<>> q;",
            "         for (auto index : from) {",
            "             dist[index] = 0;",
            "             q.emplace(index, 0);",
            "         }",
            "         while (!q.empty()) {",
            "             pll top = q.top();",
            "             q.pop();",
            "             if (top.second > dist[top.first])",
            "                 continue;",
            "             for (auto edge : list[top.first].adjacent) {",
            "                 if (top.second + edge.second < dist[edge.first]) {",
            "                     dist[edge.first] = top.second + edge.second;",
            "                     parent[edge.first] = top.first - 1;",
            "                     q.emplace(edge.first, top.second + edge.second);",
            "                 }",
            "             }",
            "         }",
            "         return {dist, parent};",
            "     }",
            " ",
            "     // Returns sorted vector of indices",
            "     vector<int> topological_sort() {",
            "         vector<int> in_degree(list.size(), 0), result;",
            "         result.reserve(list.size());",
            "         for (auto node : list)",
            "             for (auto route : node.adjacent)",
            "                 in_degree[route.first - 1]++;",
            "         queue<int> process;",
            "         for (int i = 0; i < list.size(); i++) {",
            "             if (in_degree[i] == 0) {",
            "                 process.push(i);",
            "                 result.push_back(i);",
            "             }",
            "         }",
            "         while (!process.empty()) {",
            "             int processing = process.front();",
            "             process.pop();",
            "             for (auto route : list[processing].adjacent) {",
            "                 in_degree[route.first - 1]--;",
            "                 if (in_degree[route.first - 1] == 0) {",
            "                     process.push(route.first - 1);",
            "                     result.push_back(route.first - 1);",
            "                 }",
            "             }",
            "         }",
            "         return result;",
            "     }",
            " ",
            "     mll components() {",
            "         vbl visited(n);",
            "         mll result(0);",
            "         for (int i = 0; i < n; i++) {",
            "             if (visited[i])",
            "                 continue;",
            "             vll component;",
            "             stack<ll> process;",
            "             process.push(list[i].index);",
            "             component.push_back(i);",
            "             visited[i] = true;",
            "             while (!process.empty()) {",
            "                 ll processing = process.top();",
            "                 process.pop();",
            "                 for (pll neighbor : list[processing].adjacent) {",
            "                     if (!visited[neighbor.first]) {",
            "                         process.push(neighbor.first);",
            "                         component.push_back(neighbor.first);",
            "                         visited[neighbor.first] = true;",
            "                     }",
            "                 }",
            "             }",
            "             result.push_back(component);",
            "         }",
            "         return result;",
            "     }",
            " ",
            "     pair<vll, vll> bellman_ford(vll from) {",
            "         vll distances(n, INT64_MAX);",
            "         vll parent(n, INT32_MAX);",
            "         // Bellman Ford Algorithm",
            "         for (ll &i : from)",
            "             distances[i] = 0;",
            "         for (int i = 0; i < n - 1; i++) {",
            "             for (int source = 0; source < n - 1; source++) {",
            "                 if (distances[source] == INT64_MAX)",
            "                     continue;",
            "                 for (const auto &edge : list[source].adjacent) {",
            "                     ll sink = edge.first;",
            "                     if (distances[source] + edge.second < distances[sink]) {",
            "                         distances[sink] = distances[source] + edge.second;",
            "                         parent[sink] = source;",
            "                     }",
            "                 }",
            "             }",
            "         }",
            "         // Checking for negative cycles and putting -1 if it exists.",
            "         for (ll source = 0; source < n - 1; source++) {",
            "             for (const auto &edge : list[source].adjacent) {",
            "                 ll sink = edge.first;",
            "                 if (distances[source] + edge.second < distances[sink]) {",
            "                     for (ll i : from)",
            "                         distances[i] = -1;",
            "                     return {distances, parent};",
            "                 }",
            "             }",
            "         }",
            "         return {distances, parent};",
            "     }",
            " ",
            "     vector<vector<long long>> floyd_warshall() {",
            "         vector<vector<long long>> distances(n, vector<long long>(n, INT64_MAX));",
            "         for (int i = 0; i < n; i++)",
            "             distances[i][i] = 0;",
            "         for (int i = 0; i < n; i++)",
            "             for (auto route : list[i].adjacent)",
            "                 distances[i][route.first] = route.second;",
            "         for (int k = 0; k < n; k++) {",
            "             for (int i = 0; i < n; i++) {",
            "                 for (int j = 0; j < n; j++) {",
            "                     if (distances[i][k] == INT64_MAX ||",
            "                         distances[k][j] == INT64_MAX)",
            "                         continue;",
            "                     distances[i][j] =",
            "                         min(distances[i][j], distances[i][k] + distances[k][j]);",
            "                 }",
            "             }",
            "         }",
            "         return distances;",
            "     }",
            " ",
            "     pair<ll, vll> prims_mst() {",
            "         priority_queue<pll, vpl, greater<>> routes;",
            "         vll costs(n);",
            "         vbl visited(n, false);",
            "         for (int i = 0; i < n; i++) {",
            "             if (!visited[i])",
            "                 routes.emplace(INT32_MAX, i);",
            "             while (!routes.empty()) {",
            "                 pll best = routes.top();",
            "                 routes.pop();",
            "                 if (!visited[best.second])",
            "                     costs[best.second] = best.first;",
            "                 visited[best.second] = false;",
            "                 for (const auto &path : list[best.second].adjacent)",
            "                     if (!visited[path.second])",
            "                         routes.push(path);",
            "             }",
            "         }",
            "         ll sum = accumulate(costs.begin(), costs.end(), 0);",
            "         return {sum, costs};",
            "     }",
            " };"
        ],
        "description": "A full graph class that handles it's representation and search."
    },
    "Order Statistics Tree": {
        "prefix": "$pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "typedef ordered_set tree<int, null_type, less<int>, rb_tree_tag,",
            "                         tree_order_statistics_node_update>;"
        ],
        "description": "Using the GNU Policy Based Data Structures - Order Statistics Tree"
    },
    "Polynomial Fourier Functions": {
        "prefix": "$al-fft",
        "body": [
            "class Polynomial {",
            "    static const int root = 973800541;",
            "    static const int root_1 = 595374802;",
            "    static const int root_pw = 1 << 20;",
            "    static const ll MOD = 998244353;",
            "",
            "    static ll __mod_pow(ll a, ll n) {",
            "        int res = 1;",
            "        for (a %= MOD; n > 0; n >>= 1) {",
            "            if (n & 1)",
            "                res = (res * 1ll * a) % MOD;",
            "            a = (a * 1ll * a) % MOD;",
            "        }",
            "        return res;",
            "    }",
            "",
            "   public:",
            "    int order;",
            "    vll coeff;",
            "",
            "    explicit Polynomial(vll coefficients) {",
            "        order = coefficients.size() - 1;",
            "        coeff = coefficients;",
            "        this->resize(order);",
            "    }",
            "    Polynomial(const Polynomial &copy) {",
            "        order = copy.order;",
            "        coeff = vll(copy.coeff);",
            "    }",
            "    void resize(int order) {",
            "        int size;",
            "        for (size = 1; size < order + 1; size *= 2)",
            "            ;",
            "        coeff.resize(size);",
            "    }",
            "",
            "    void ntt(bool invert = false) {",
            "        int n = coeff.size();",
            "        for (int i = 1, j = 0; i < n; i++) {",
            "            int bit = n >> 1;",
            "            for (; j & bit; bit >>= 1)",
            "                j ^= bit;",
            "            j ^= bit;",
            "            if (i < j)",
            "                swap(coeff[i], coeff[j]);",
            "        }",
            "        for (int len = 2; len <= n; len <<= 1) {",
            "            int wlen = invert ? root_1 : root;",
            "            for (int i = len; i < root_pw; i <<= 1)",
            "                wlen = (int)(1LL * wlen * wlen % MOD);",
            "            for (int i = 0; i < n; i += len) {",
            "                int w = 1;",
            "                for (int j = 0; j < len / 2; j++) {",
            "                    int u = coeff[i + j],",
            "                        v = (ll)((coeff[i + j + len / 2] * 1ll * w) % MOD);",
            "                    coeff[i + j] = u + v < MOD ? u + v : u + v - MOD;",
            "                    coeff[i + j + len / 2] = u - v >= 0 ? u - v : u - v + MOD;",
            "                    w = (int)((w * 1ll * wlen) % MOD);",
            "                }",
            "            }",
            "        }",
            "        if (invert) {",
            "            int n_1 = __mod_pow(n, MOD - 2);",
            "            for (ll &x : coeff)",
            "                x = (ll)((x * 1ll * n_1) % MOD);",
            "        }",
            "    }",
            "",
            "    friend Polynomial operator*(const Polynomial &a, const Polynomial &b) {",
            "        Polynomial x(a), y(b);",
            "        int order = a.order + b.order;",
            "        x.resize(order);",
            "        y.resize(order);",
            "        x.ntt();",
            "        y.ntt();",
            "        int size = x.coeff.size();",
            "        vll poly(size);",
            "        for (int i = 0; i < size; i++) {",
            "            poly[i] = (x.coeff[i] * y.coeff[i]) % MOD;",
            "        }",
            "        Polynomial res(poly);",
            "        res.ntt(true);",
            "        res.order = order;",
            "        return res;",
            "    }",
            "",
            "    friend Polynomial operator^(const Polynomial &a, ll pow) {",
            "        Polynomial x(a);",
            "        int order = a.order * pow;",
            "        x.resize(order);",
            "        x.ntt();",
            "        int size = x.coeff.size();",
            "        vll poly(size);",
            "        for (int i = 0; i < size; i++)",
            "            poly[i] = __mod_pow(x.coeff[i], pow);",
            "        Polynomial res(poly);",
            "        res.ntt(true);",
            "        res.order = order;",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Polynomial Multiplication using Fast Fourier Transforms (NTT)"
    },
    "KMP String Search": {
        "prefix": "$al-kmp",
        "body": [
            "class KMPstring {",
            "    string pattern;",
            "    vll lps;",
            "",
            "   public:",
            "    explicit KMPstring(const string &pattern) {",
            "        this->pattern = pattern;",
            "        ll m = pattern.size();",
            "        lps = vll(m + 1, 0);",
            "        ll i = 0, j = -1;",
            "        lps[0] = -1;",
            "        while (i < m) {",
            "            while (j >= 0 && pattern[i] != pattern[j])",
            "                j = lps[j];",
            "            i++, j++;",
            "            lps[i] = j;",
            "        }",
            "    }",
            "    vll match(const string &text) {",
            "        ll n = text.size(), m = pattern.size();",
            "        vll matches, m_length(n);",
            "        ll i = 0, j = 0;",
            "        while (i < n) {",
            "            while (j >= 0 && text[i] != pattern[j])",
            "                j = lps[j];",
            "            i++, j++;",
            "            m_length[i - 1] = j;",
            "            if (j == m) {",
            "                matches.push_back(i - m);",
            "                j = lps[j];",
            "            }",
            "        }",
            "        return move(matches); // or m_length",
            "    }",
            "};"
        ],
        "description": "Search in any string using KMP and get some associated partial-match data"
    },
    "Tests - General Style": {
        "prefix": "$tests",
        "body": [
            "ll t;",
            "cin >> t;",
            "while(t--){",
            "    $0",
            "}"
        ],
        "description": "Loop over all test cases"
    },
    "Tests - Codejam Style": {
        "prefix": "$cj-tests",
        "body": [
            "int tests; cin >> tests;",
            "for (int test = 1; test <= tests; test++) {",
            "    $0",
            "    cout << \"Case #\" << test << \": \" << 7 << endl;",
            "}"
        ],
        "description": "Loops over test cases as needed in Google contest"
    },
    "General Modular Integer Class": {
        "prefix": "$gn-mod",
        "body": [
            "class ModfieldInt {",
            "    public:",
            "     long long value;",
            "     const static long long mod = 1e9 + 7;",
            "     ModfieldInt(long long value = 0) {",
            "         this->value = value;",
            "     }",
            "     friend ModfieldInt operator^(ModfieldInt val, long long power) {",
            "         long long res = 1, cum = (val.value % val.mod);",
            "         for (; power > 0; power >>= 1) {",
            "             if (power & 1)",
            "                 res = (res * cum) % val.mod;",
            "             cum = (cum * cum) % val.mod;",
            "         }",
            "         return ModfieldInt(res);",
            "     }",
            "     friend ModfieldInt operator+(ModfieldInt a, ModfieldInt b) {",
            "         return ModfieldInt((a.value + b.value) % b.mod);",
            "     }",
            "     friend ModfieldInt operator-(ModfieldInt a, ModfieldInt b) {",
            "         return ModfieldInt((a.value - b.value + b.mod) % b.mod);",
            "     }",
            "     friend ModfieldInt operator*(ModfieldInt a, ModfieldInt b) {",
            "         return ModfieldInt((a.value * b.value) % a.mod);",
            "     }",
            "     friend ModfieldInt operator/(ModfieldInt a, ModfieldInt b) {",
            "         return a * (b ^ (b.mod - 2));",
            "     }",
            " };"
        ],
        "description": "Overrides operators to be Modulo friendly"
    },
    "General Fractions Class": {
        "prefix": "$gn-frac",
        "body": [
            "struct Fraction {",
            "    long long p, q;",
            "",
            "    long long mod_power(long long a, long long b, long long m) {",
            "        long long cumulative = a, result = 1;",
            "        for (; b > 0; b /= 2) {",
            "            if (b % 2 == 1)",
            "                result = (result * cumulative) % m;",
            "            cumulative = (cumulative * cumulative) % m;",
            "        }",
            "        return result;",
            "    }",
            "",
            "    Fraction(long long p, long long q) {",
            "        long long gcd = 1;",
            "        if (q != 0 && p != 0)",
            "            for (long long a = abs(p), b = abs(q); b > 0;",
            "                 gcd = b, b = a % b, a = gcd)",
            "                ;",
            "        this->p = p / gcd, this->q = q / gcd;",
            "        if (this->q < 0)",
            "            this->q *= -1, this->p *= -1;",
            "    }",
            "",
            "    friend Fraction operator+(Fraction a, Fraction b) {",
            "        return {a.p * b.q + a.q * b.p, a.q * b.q};",
            "    }",
            "    friend Fraction operator-(Fraction a, Fraction b) {",
            "        return {a.p * b.q - a.q * b.p, a.q * b.q};",
            "    }",
            "    friend Fraction operator*(Fraction a, Fraction b) {",
            "        return {a.p * b.p, a.q * b.q};",
            "    }",
            "    friend Fraction operator/(Fraction a, Fraction b) {",
            "        return {a.p * b.q, a.q * b.p};",
            "    }",
            "    friend long long operator%(Fraction &x, long long y) {",
            "        return ((x.p % y) * mod_power(x.q, y - 2, y)) % y;",
            "    }",
            "    friend Fraction operator^(Fraction a, long long power) {",
            "        return {a.p ^ power, a.q ^ power};",
            "    }",
            "    friend bool operator<(Fraction a, Fraction b) {",
            "        return a.p * b.q < a.q * b.p;",
            "    }",
            "    friend bool operator<=(Fraction a, Fraction b) {",
            "        return a.p * b.q <= a.q * b.p;",
            "    }",
            "    friend bool operator>(Fraction a, Fraction b) {",
            "        return a.p * b.q > a.q * b.p;",
            "    }",
            "    friend bool operator>=(Fraction a, Fraction b) {",
            "        return a.p * b.q >= a.q * b.p;",
            "    }",
            "    friend bool operator==(Fraction a, Fraction b) {",
            "        return a.p * b.q == a.q * b.p;",
            "    }",
            "    friend bool operator!=(Fraction a, Fraction b) {",
            "        return a.p * b.q != a.q * b.p;",
            "    }",
            "    static Fraction slope(pair<long long, long long> &pt1,",
            "                          pair<long long, long long> &pt2) {",
            "        return {pt1.second - pt2.second, pt1.first - pt2.first};",
            "    }",
            "    long double decimal() {",
            "        return (long double)this->p / (long double)this->q;",
            "    }",
            "};",
        ],
        "description": "Overrides operators to be Fractions friendly"
    },
    "Line Container for DP Convex Hull Trick": {
        "prefix": "$ds-linecontainer",
        "body": [
            "class LineContainer {",
            "    private:",
            "     struct Line {",
            "         mutable long long slope, constt, p;",
            "         bool operator<(const Line &o) const {",
            "             return slope < o.slope;",
            "         }",
            "         bool operator<(long long x) const {",
            "             return p < x;",
            "         }",
            "     };",
            " ",
            "     multiset<Line, less<>> lines;",
            "     // (for doubles, use inf = 1/.0, div(a,b) = a/b)",
            "     bool __is_max_query = false;",
            "     const long long inf = LLONG_MAX;",
            "     long long __div(long long a, long long b) {  // floored division",
            "         return a / b - ((a ^ b) < 0 && a % b);",
            "     }",
            "     bool __intersect(multiset<Line>::iterator x, multiset<Line>::iterator y) {",
            "         if (y == lines.end()) {",
            "             x->p = inf;",
            "             return false;",
            "         }",
            "         if (x->slope == y->slope)",
            "             x->p = x->constt > y->constt ? inf : -inf;",
            "         else",
            "             x->p = __div(y->constt - x->constt, x->slope - y->slope);",
            "         return x->p >= y->p;",
            "     }",
            " ",
            "    public:",
            "     LineContainer(bool is_max = false) {",
            "         this->__is_max_query = is_max;",
            "     }",
            "     void add(long long slope, long long constt) {",
            "         if (!__is_max_query) {",
            "             slope = -slope;",
            "             constt = -constt;",
            "         }",
            "         auto z = lines.insert({slope, constt, 0}), y = z++, x = y;",
            "         while (__intersect(y, z))",
            "             z = lines.erase(z);",
            "         if (x != lines.begin() && __intersect(--x, y))",
            "             __intersect(x, y = lines.erase(y));",
            "         while ((y = x) != lines.begin() && (--x)->p >= y->p)",
            "             __intersect(x, lines.erase(y));",
            "     }",
            "     long long query(long long x) {",
            "         assert(!lines.empty());",
            "         auto l = *lines.lower_bound(x);",
            "         return (l.slope * x + l.constt) * (__is_max_query ? 1 : -1);",
            "     }",
            " };"
        ],
        "description": "Line container to store slope and constants and aid DP Convex Hull Trick"
    },
    "Suffix Array": {
        "prefix": "$al-suffixarr",
        "body": [
            "class SuffixArray {",
            "    public:",
            "     string s;",
            "     int n, __log_n;",
            "     vector<int> sa;            // Suffix Array",
            "     vector<vector<int>> ra;    // Rank Array",
            "     vector<vector<int>> _lcp;  // Longest Common Prefix",
            "     vector<int> __msb, __dollar;",
            " ",
            "     SuffixArray(string st) {",
            "         n = st.size();",
            "         __log_n = log2(n) + 1;",
            "         ra = vector<vector<int>>(__log_n, vector<int>(n));",
            "         sa = vector<int>(n);",
            " ",
            "         __msb = vector<int>(n);",
            "         int mx = -1;",
            "         for (int i = 0; i < n; i++) {",
            "             if (i >= (1 << (mx + 1)))",
            "                 mx++;",
            "             __msb[i] = mx;",
            "         }",
            "         this->s = st;",
            "         build_SA();",
            "     }",
            " ",
            "     void __counting_sort(int l, int k) {",
            "         int maxi = max(300, n);",
            "         vector<int> count(maxi, 0), temp_sa(n, 0);",
            "         for (int i = 0; i < n; i++) {",
            "             int idx = (i + k < n ? ra[l][i + k] : 0);",
            "             count[idx]++;",
            "         }",
            "         for (int i = 0, sum = 0; i < maxi; i++) {",
            "             int t = count[i];",
            "             count[i] = sum;",
            "             sum += t;",
            "         }",
            "         for (int i = 0; i < n; i++) {",
            "             int idx = sa[i] + k < n ? ra[l][sa[i] + k] : 0;",
            "             temp_sa[count[idx]++] = sa[i];",
            "         }",
            "         sa = temp_sa;",
            "     }",
            " ",
            "     void build_SA() {",
            "         for (int i = 0; i < n; i++)",
            "             ra[0][i] = s[i];",
            "         for (int i = 0; i < n; i++)",
            "             sa[i] = i;",
            "         for (int i = 0; i < __log_n - 1; i++) {",
            "             int k = (1 << i);",
            "             if (k >= n)",
            "                 break;",
            "             __counting_sort(i, k);",
            "             __counting_sort(i, 0);",
            "             int rank = 0;",
            "             ra[i + 1][sa[0]] = rank;",
            "             for (int j = 1; j < n; j++)",
            "                 if (ra[i][sa[j]] == ra[i][sa[j - 1]] &&",
            "                     ra[i][sa[j] + k] == ra[i][sa[j - 1] + k])",
            "                     ra[i + 1][sa[j]] = rank;",
            "                 else",
            "                     ra[i + 1][sa[j]] = ++rank;",
            "         }",
            "     }",
            "     void build_LCP() {",
            "         _lcp = vector<vector<int>>(__log_n, vector<int>(n));",
            "         for (int i = 0; i < n - 1; i++) {  // Build the LCP array in O(NlogN)",
            "             int x = sa[i], y = sa[i + 1], k, ret = 0;",
            "             for (k = __log_n - 1; k >= 0 && x < n && y < n; k--) {",
            "                 if ((1 << k) >= n)",
            "                     continue;",
            "                 if (ra[k][x] == ra[k][y])",
            "                     x += 1 << k, y += 1 << k, ret += 1 << k;",
            "             }",
            "             if (ret >= __dollar[sa[i]] - sa[i])",
            "                 ret = __dollar[sa[i]] - sa[i];",
            "             _lcp[0][i] = ret;  // LCP[i] shouldn’t exceed __dollar[sa[i]]",
            "         }  // __dollar[i] : index of __dollar to the right of i.",
            "         _lcp[0][n - 1] = 10 * n;",
            "         for (int i = 1; i < __log_n; i++) {  // O(1) RMQ structure in O(NlogN)",
            "             int add = (1 << (i - 1));",
            "             if (add >= n)",
            "                 break;  // small optimization",
            "             for (int j = 0; j < n; j++)",
            "                 if (j + add < n)",
            "                     _lcp[i][j] = min(_lcp[i - 1][j], _lcp[i - 1][j + add]);",
            "                 else",
            "                     _lcp[i][j] = _lcp[i - 1][j];",
            "         }",
            "     }",
            " ",
            "     int lcp(int x, int y) {",
            "         // O(1) LCP. x & y are indexes of the suffix in sa!",
            "         if (x == y)",
            "             return __dollar[sa[x]] - sa[x];",
            "         if (x > y)",
            "             swap(x, y);",
            "         y--;",
            "         int idx = __msb[y - x + 1], sub = (1 << idx);",
            "         return min(_lcp[idx][x], _lcp[idx][y - sub + 1]);",
            "     }",
            " ",
            "     bool equal(int i, int j, int p, int q) {",
            "         if (j - i != q - p)",
            "             return false;",
            "         int idx = __msb[j - i + 1], sub = (1 << idx);",
            "         return ra[idx][i] == ra[idx][p] &&",
            "                ra[idx][j - sub + 1] == ra[idx][q - sub + 1];",
            "     }  // Note : Do not forget to add a terminating ’$’",
            " };"
        ],
        "description": "Generates the Suffix array of a string."
    },
    "Geometry - Points Class with Convex Hull": {
        "prefix": "$al-convexhull",
        "body": [
            "class Point {",
            "    public:",
            "     typedef long long coord_t;",
            "     coord_t x, y;",
            " ",
            "     Point(coord_t coord_x = 0, coord_t coord_y = 0) {",
            "         this->x = coord_x;",
            "         this->y = coord_y;",
            "     }",
            "     Point(pair<coord_t, coord_t> coord) {",
            "         this->x = coord.first;",
            "         this->y = coord.second;",
            "     }",
            "     static coord_t area(const Point &a, const Point &b, const Point &c) {",
            "         // Area function: area < 0 = clockwise, area > 0 counterclockwise",
            "         return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y);",
            "     };",
            "     static coord_t area(const vector<Point> &polygon) {",
            "         int n = polygon.size();",
            "         coord_t ans = 0;",
            "         for (int i = 0; i < n; i++) {",
            "             ans += polygon[i].x * polygon[(i + 1) % n].y -",
            "                    polygon[i].y * polygon[(i + 1) % n].x;",
            "         }",
            "     }",
            "     friend bool operator<(const Point &a, const Point &b) {",
            "         return (a.x != b.x) ? a.x < b.x : a.y < b.y;",
            "     }",
            "     friend bool operator==(const Point &a, const Point &b) {",
            "         return (a.x == b.x) && (a.y == b.y);",
            "     }",
            "     friend istream &operator>>(istream &in, Point &p) {",
            "         in >> p.x >> p.y;",
            "         return in;",
            "     }",
            "     friend ostream &operator<<(ostream &out, Point &p) {",
            "         out << p.x << \" \" << p.y;",
            "         return out;",
            "     }",
            "     static coord_t sq_dist(const Point &a, const Point &b) {",
            "         return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);",
            "     }",
            " ",
            "     static vector<Point> convex_hull(vector<Point> &a) {",
            "         if (a.size() <= 3)",
            "             return a;",
            "         int n = a.size(), k = 0;",
            "         sort(a.begin(), a.end());",
            "         vector<Point> result(2 * n);",
            "         for (int i = 0; i < n; ++i) {",
            "             while (k >= 2 && area(result[k - 2], result[k - 1], a[i]) <= 0)",
            "                 k--;",
            "             result[k++] = a[i];",
            "         }",
            "         for (int i = n - 1, t = k + 1; i > 0; --i) {",
            "             while (k >= t && area(result[k - 2], result[k - 1], a[i - 1]) <= 0)",
            "                 k--;",
            "             result[k++] = a[i - 1];",
            "         }",
            "         result.resize(k - 1);",
            "         return result;",
            "     }",
            " };"
        ]
    },
    "Diameter of Tree": {
        "prefix": "$al-diameter",
        "body": [
            "ll diameter(Tree tree) {",
            "    ll n = tree.list.size() + 1;",
            "    vbl visited(n + 1, false);",
            "    vll distances(n + 1, -1);",
            "    queue<pll> q;",
            "    q.push({tree.root->index, 0});",
            "    ll node_max = tree.root->index, distance_max = 0;",
            "    while (!q.empty()) {",
            "        auto node = q.front();",
            "        q.pop();",
            "        if (node.second < distance_max) {",
            "            distance_max = node.second;",
            "            node_max = node.first;",
            "        }",
            "",
            "        for (auto neighbor : tree.list[node.first].adjacent) {",
            "            if (!visited[neighbor->index]) {",
            "                auto d = node.second + 1;",
            "                q.push({neighbor->index, d});",
            "                visited[neighbor->index] = 1;",
            "            }",
            "        }",
            "    }",
            "    visited = vbl(n + 1, false);",
            "    q.push({node_max, 0});",
            "    distance_max = 0;",
            "    while (!q.empty()) {",
            "        auto node = q.front();",
            "        q.pop();",
            "        maximize(distance_max, node.second);",
            "        for (auto neighbor : tree.list[node.first].adjacent) {",
            "            if (!visited[neighbor->index]) {",
            "                auto d = node.second + 1;",
            "                q.push({neighbor->index, d});",
            "                visited[neighbor->index] = 1;",
            "            }",
            "        }",
            "    }",
            "}"
        ]
    },
    "Extended Euclid GCD Algorithm": {
        "prefix": "$al-gcd",
        "body": [
            "ll gcd(ll a, ll b, ll &x, ll &y) {",
            "    int g = a; x = 1, y = 0;",
            "    if (b) g = gcd(b, a % b, y, x), y -= a / b * x;",
            "    return g;",
            "}",
            " ",
            "ll mod_inverse(ll a, ll mod) {",
            "  ll x, y;",
            "  gcd(a, mod, x, y);",
            "  return (x + mod) % mod;",
            "}"
        ],
        "description": "Performs the Extended Euclid Algorithm (can also compute mod inverse)"
    },
    "Modular Arithmetic": {
        "prefix": "$gn-modutils",
        "body": [
            "long long mod_power(long long a, long long b, long long MOD) {",
            "    long long cumulative = a, result = 1;",
            "    for (; b > 0; b /= 2) {",
            "        if (b % 2 == 1) result = (result * cumulative) % MOD;",
            "        cumulative = (cumulative * cumulative) % MOD;",
            "    } return result;",
            "}",
            "",
            "long long mod_multiply(long long a, long long b, long long MOD) {",
            "    long long cumulative = a, result = 0;",
            "    for (; b > 0; b /= 2) {",
            "        if (b % 2 == 1) result = (result + cumulative) % MOD;",
            "        cumulative = (cumulative + cumulative) % MOD;",
            "    } return result;",
            "}",
            "",
            "long long mod_inverse(long long a, long long MOD) {",
            "    return mod_power(a, MOD-2, MOD);",
            "}"
        ],
        "description": "Performs the Extended Euclid Algorithm (can also compute mod inverse)"
    },
    "Merge Sort with Inversion Count": {
        "prefix": "$al-mergesort",
        "body": [
            "long long _inv = 0;",
            "void _merge(int A[], int start, int mid, int end) {",
            "    int result[end - start];",
            "    for (int x = start, y = mid; x < mid || y < end; ) {",
            "        if (x < mid && (y >= end || A[x] <= A[y])) { result[x + y - start - mid] = A[x]; x++; }",
            "        else { result[x + y - start - mid] = A[y]; y++; _inv += mid - x; }",
            "    } for (int i = start; i < end; i++) A[i] = result[i - start];",
            "}",
            "void sort(int A[], int start, int end) {",
            "    if (start >= end - 1) return;",
            "    sort(A, start, (start + end) / 2);",
            "    sort(A, (start + end) / 2, end);",
            "    _merge(A, start, (start + end) / 2, end);",
            "}"
        ],
        "description": "Stores the number of inversions in total in the _inv variable"
    },
    "Binary Search": {
        "prefix": "$al-binsearch",
        "body": [
            "ll result = 0;",
            "for (ll top = $1, bot = $2, mid = bot + (top - bot) / 2; bot <= top;",
            "     mid = bot + (top - bot) / 2) {",
            "    if ($3(mid) && !$3(mid - 1)) {",
            "        result = mid;",
            "        break;",
            "    }",
            "    ($3(mid)) ? (top = mid - 1) : (bot = mid + 1);",
            "}"
        ],
        "description": "Performs Lower Bound Binary Search, customise for Upper and Exact bounds"
    },
    "Frequency Compress": {
        "prefix": "$gn-freqcompress",
        "body": [
            "template <class Type>",
            "vector<pair<Type, unsigned long>> frequency_compress(vector<Type> list) {",
            "    vector<pair<Type, unsigned long>> result;",
            "    pair<Type, unsigned long> current = {list[0], 1};",
            "    for (int i = 1; i < list.size(); i++) {",
            "        if (list[i] == current.first)",
            "            current.second++;",
            "        else {",
            "            result.push_back(current);",
            "            current = {list[i], 1};",
            "        }",
            "    }",
            "    result.push_back(current);",
            "    return result;",
            "}"
        ],
        "description": "Converts array with repeated elements in sequence to (element, frequency)"
    },
    "DP - Edit Distance": {
        "prefix": "$dp-editdist",
        "body": [
            "mll dp(5001, v(5001, 1e15));",
            "#define INSERT_COST 1ll",
            "#define DELETE_COST 1ll",
            "#define REPLACE_COST 1ll",
            "",
            "template <typename T>",
            "void edit_dist(const vector<T> &str1, const vector<T> &str2, ll m, ll n) {",
            "    for (ll l1 = 0; l1 <= m; l1++) {",
            "        for (ll l2 = 0; l2 <= n; l2++) {",
            "            if (l1 == 0) {",
            "                dp[l1][l2] = l2 * INSERT_COST;",
            "            } else if (l2 == 0) {",
            "                dp[l1][l2] = l1 * DELETE_COST;",
            "            } else if (str1[l1 - 1] == str2[l2 - 1]) {",
            "                dp[l1][l2] = dp[l1 - 1][l2 - 1];",
            "            } else {",
            "                dp[l1][l2] = min(min(DELETE_COST + dp[l1 - 1][l2],",
            "                                     INSERT_COST + dp[l1][l2 - 1]),",
            "                                 REPLACE_COST + dp[l1 - 1][l2 - 1]);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code for computing the edit distance between two strings"
    },
    "Tree": {
        "prefix": "$ds-tree",
        "body": [
            "class Tree {",
            "    public:",
            "     struct Node {",
            "         vector<Node *> adjacent;",
            "         Node *parent = nullptr;",
            "         long long start_time = 0, end_time = 0, subtree_size = 1;",
            "         unsigned long depth = 0, height = 0;",
            "         unsigned long index = INT32_MAX;",
            "     };",
            " ",
            "     vector<Node> list;",
            "     Node *root = nullptr;",
            "     vector<vector<Node *>> __anc;",
            " ",
            "     Tree(int n = 1e5) {",
            "         list.resize(n);",
            "         this->root = &list[0];",
            "         for (int i = 0; i < n; i++)",
            "             list[i].index = i;",
            "     }",
            "     void add_edge(int x, int y) {",
            "         list[x].adjacent.push_back(&list[y]);",
            "         list[y].adjacent.push_back(&list[x]);",
            "     }",
            " ",
            "     Node *lca(Node *a, Node *b) {",
            "         if (b->depth > a->depth)",
            "             swap(a, b);",
            "         for (int ptr = __anc[0].size() - 1; a->depth > b->depth && ptr >= 0;",
            "              ptr--) {",
            "             if (__anc[a->index][ptr] != nullptr &&",
            "                 __anc[a->index][ptr]->depth >= b->depth)",
            "                 a = __anc[a->index][ptr];",
            "         }",
            "         if (a == b)",
            "             return a;",
            "         for (long step = __anc[0].size() - 1; step >= 0; step--) {",
            "             if (__anc[a->index][step] != __anc[b->index][step])",
            "                 a = __anc[a->index][step], b = __anc[b->index][step];",
            "         }",
            "         return a->parent;",
            "     }",
            "     Node *ancestor(Node *a, int degree) {",
            "         ll target_depth = a->depth - degree;",
            "         for (int ptr = __anc[0].size() - 1; a->depth > target_depth && ptr >= 0;",
            "              ptr--) {",
            "             if (__anc[a->index][ptr] != nullptr &&",
            "                 __anc[a->index][ptr]->depth >= target_depth)",
            "                 a = __anc[a->index][ptr];",
            "         }",
            "         return a;",
            "     }",
            "     int __build(Node *root = nullptr, int time = 0) {",
            "         if (root == nullptr)",
            "             root = this->root;",
            "         root->start_time = time;",
            "         for (auto child : root->adjacent) {",
            "             if (child == root->parent)",
            "                 continue;",
            "             child->parent = root;",
            "             child->depth = root->depth + 1;",
            "             time = __build(child, time + 1);",
            "             root->height = max(root->height, child->height + 1);",
            "             root->subtree_size += child->subtree_size;",
            "         }",
            "         root->end_time = time;",
            "         return time;",
            "     }",
            "     void __build_lca_matrix() {",
            "         int n = list.size();",
            "         __anc = *new vector<vector<Node *>>(",
            "             n, vector<Node *>(log2(n) + 1, nullptr));",
            "         for (int i = 0; i < list.size(); i++)",
            "             __anc[i][0] = list[i].parent;",
            "         for (int level = 1; level < __anc[0].size(); level++)",
            "             for (int i = 0; i < list.size(); i++) {",
            "                 if (__anc[i][level - 1] == nullptr)",
            "                     continue;",
            "                 __anc[i][level] = __anc[__anc[i][level - 1]->index][level - 1];",
            "             }",
            "     }",
            " };"
        ],
        "description": "Builds the Tree with DFS Parameters and Handles LCA queries"
    },
    "Lazy Segment Tree": {
        "prefix": "$ds-lazysegtree",
        "body": [
            "template <typename Type>",
            "class LazySegtree {",
            "    int size;",
            "    vector<Type> tree, lazy;",
            "    Type _default;",
            "    function<Type(Type, Type)> _operation;",
            "    function<Type(Type, Type)> _setter;",
            "",
            "    void split(int node) {",
            "        lazy[2 * node] = _setter(lazy[2 * node], lazy[node]);",
            "        tree[2 * node] = _setter(tree[2 * node], lazy[node]);",
            "        lazy[2 * node + 1] = _setter(lazy[2 * node + 1], lazy[node]);",
            "        tree[2 * node + 1] = _setter(tree[2 * node + 1], lazy[node]);",
            "        lazy[node] = _default;",
            "    }",
            "    void merge(int node) {",
            "        tree[node] = _operation(tree[2 * node], tree[2 * node + 1]);",
            "    }",
            "",
            "   public:",
            "    LazySegtree(int n, const function<Type(Type, Type)> &op,",
            "                const function<Type(Type, Type)> &set, const Type identity) {",
            "        for (size = 1; size < n; size <<= 1)",
            "            ;",
            "        _setter = set, _operation = op, _default = identity;",
            "        tree.assign(2 * size, _default);",
            "        lazy.assign(2 * size, _default);",
            "    }",
            "",
            "    void modify(int l, int r, Type delta, int node = 1, int x = 0, int y = -1) {",
            "        if (y == -1)",
            "            y = size;",
            "        if (r <= x || l >= y)",
            "            return;",
            "        if (l <= x && y <= r) {",
            "            lazy[node] = _setter(lazy[node], delta);",
            "            tree[node] = _setter(tree[node], delta);",
            "            return;",
            "        }",
            "        split(node);",
            "        modify(l, r, delta, 2 * node, x, (x + y) / 2);",
            "        modify(l, r, delta, 2 * node + 1, (x + y) / 2, y);",
            "        merge(node);",
            "    }",
            "    Type query(int l, int r, int node = 1, int x = 0, int y = -1) {",
            "        if (y == -1)",
            "            y = size;",
            "        if (r <= x || l >= y)",
            "            return _default;",
            "        if (l <= x && y <= r) {",
            "            return tree[node];",
            "        }",
            "        split(node);",
            "        Type lres = query(l, r, 2 * node, x, (x + y) / 2);",
            "        Type rres = query(l, r, 2 * node + 1, (x + y) / 2, y);",
            "        merge(node);",
            "        return _operation(lres, rres);",
            "    }",
            "};"
        ],
        "description": "A templated lazy segment tree (Hard code functions for speed)"
    },
    "Dinic's algorithm for Max Flow": {
        "prefix": "$al-dinic",
        "body": [
            "struct Dinic {",
            "    struct Edge {",
            "        int u, v;",
            "        ll cap, flow;",
            "        Edge() : u(0), v(0), cap(0), flow(0) {",
            "        }",
            "        Edge(int uu, int vv, ll ccap) : u(uu), v(vv), cap(ccap), flow(0) {",
            "        }",
            "    };",
            "",
            "    int size;",
            "    vector<Edge> edges;",
            "    vector<vector<int>> adjacency;",
            "    vector<int> d, pt;",
            "    Dinic(int NN) : size(NN), edges(0), adjacency(size), d(size), pt(size) {",
            "    }",
            "    void add_edge(int u, int v, ll cap_f, ll cap_r = 0) {",
            "        if (u != v) {",
            "            edges.emplace_back(Edge(u, v, cap_f));",
            "            adjacency[u].emplace_back(edges.size() - 1);",
            "            edges.emplace_back(Edge(v, u, cap_r));",
            "            adjacency[v].emplace_back(edges.size() - 1);",
            "        }",
            "    }",
            "    bool __bfs(int source, int sink) {",
            "        queue<int> q({source});",
            "        fill(d.begin(), d.end(), size + 1);",
            "        d[source] = 0;",
            "        while (!q.empty()) {",
            "            int u = q.front();",
            "            q.pop();",
            "            if (u == sink)",
            "                break;",
            "            for (int k : adjacency[u]) {",
            "                Edge &e = edges[k];",
            "                if (e.flow < e.cap && d[e.v] > d[e.u] + 1) {",
            "                    d[e.v] = d[e.u] + 1;",
            "                    q.emplace(e.v);",
            "                }",
            "            }",
            "        }",
            "        return d[sink] != size + 1;",
            "    }",
            "",
            "    ll __dfs(int u, int sink, ll flow = -1) {",
            "        if (u == sink || flow == 0)",
            "            return flow;",
            "        for (int &i = pt[u]; i < (int)adjacency[u].size(); ++i) {",
            "            Edge &e = edges[adjacency[u][i]];",
            "            Edge &oe = edges[adjacency[u][i] ^ 1];",
            "            if (d[e.v] == d[e.u] + 1) {",
            "                ll amt = e.cap - e.flow;",
            "                if (flow != -1 && amt > flow)",
            "                    amt = flow;",
            "                if (ll pushed = __dfs(e.v, sink, amt)) {",
            "                    e.flow += pushed;",
            "                    oe.flow -= pushed;",
            "                    return pushed;",
            "                }",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "    ll max_flow(int source, int sink) {",
            "        ll total = 0;",
            "        while (__bfs(source, sink)) {",
            "            fill(pt.begin(), pt.end(), 0);",
            "            while (ll flow = __dfs(source, sink))",
            "                total += flow;",
            "        }",
            "        return total;",
            "    }",
            "};"
        ],
        "description": "Get's the max flow and corresponding edge assigments"
    },
    "Push Relabel algorithm for Max Flow": {
        "prefix": "$al-pushrelabel",
        "body": [
            "struct PushRelabel {",
            "    struct Edge {",
            "        ll from, to, cap, flow, index;",
            "        Edge(ll dfrom, ll dto, ll dcap, ll dflow, ll dindex)",
            "            : from(dfrom), to(dto), cap(dcap), flow(dflow), index(dindex) {",
            "        }",
            "    };",
            "",
            "    ll size;",
            "    vector<vector<Edge>> graph;",
            "    vector<ll> excess;",
            "    vector<ll> dist, active, count;",
            "    queue<ll> q;",
            "",
            "    PushRelabel(ll n)",
            "        : size(n),",
            "          graph(size),",
            "          excess(size),",
            "          dist(size),",
            "          active(size),",
            "          count(2 * size) {",
            "    }",
            "    void add_edge(ll from, ll to, ll cap) {",
            "        graph[from].push_back(Edge(from, to, cap, 0, graph[to].size()));",
            "        if (from == to)",
            "            graph[from].back().index++;",
            "        graph[to].push_back(Edge(to, from, 0, 0, graph[from].size() - 1));",
            "    }",
            "    void __enqueue(ll v) {",
            "        if (!active[v] && excess[v] > 0) {",
            "            active[v] = true;",
            "            q.push(v);",
            "        }",
            "    }",
            "    void __push(Edge &e) {",
            "        ll amt = ll(min(excess[e.from], ll(e.cap - e.flow)));",
            "        if (dist[e.from] <= dist[e.to] || amt == 0)",
            "            return;",
            "        e.flow += amt;",
            "        graph[e.to][e.index].flow -= amt;",
            "        excess[e.to] += amt;",
            "        excess[e.from] -= amt;",
            "        __enqueue(e.to);",
            "    }",
            "    void __gap(ll k) {",
            "        for (ll v = 0; v < size; v++) {",
            "            if (dist[v] < k)",
            "                continue;",
            "            count[dist[v]]--;",
            "            dist[v] = max(dist[v], size + 1);",
            "            count[dist[v]]++;",
            "            __enqueue(v);",
            "        }",
            "    }",
            "    void __relabel(ll v) {",
            "        count[dist[v]]--;",
            "        dist[v] = 2 * size;",
            "        for (ll i = 0; i < (ll)graph[v].size(); i++)",
            "            if (graph[v][i].cap - graph[v][i].flow > 0)",
            "                dist[v] = min(dist[v], dist[graph[v][i].to] + 1);",
            "        count[dist[v]]++;",
            "        __enqueue(v);",
            "    }",
            "    void __discharge(ll v) {",
            "        for (ll i = 0; excess[v] > 0 && i < (ll)graph[v].size(); i++)",
            "            __push(graph[v][i]);",
            "        if (excess[v] > 0) {",
            "            if (count[dist[v]] == 1)",
            "                __gap(dist[v]);",
            "            else",
            "                __relabel(v);",
            "        }",
            "    }",
            "    ll max_flow(ll s, ll t) {",
            "        count[0] = size - 1;",
            "        count[size] = 1;",
            "        dist[s] = size;",
            "        active[s] = active[t] = true;",
            "        for (ll i = 0; i < (ll)graph[s].size(); i++) {",
            "            excess[s] += graph[s][i].cap;",
            "            __push(graph[s][i]);",
            "        }",
            "        while (!q.empty()) {",
            "            ll v = q.front();",
            "            q.pop();",
            "            active[v] = false;",
            "            __discharge(v);",
            "        }",
            "        ll totflow = 0;",
            "        for (ll i = 0; i < (ll)graph[s].size(); i++)",
            "            totflow += graph[s][i].flow;",
            "        return totflow;",
            "    }",
            "};",
        ],
        "description": "Get's the max flow and corresponding edge assigments"
    },
    "Hopkroft-Karp maximal bipartite matching": {
        "prefix": "$al-hopkroft",
        "body": [
            "struct HopcroftKarp {",
            "    static const int INF = 1e9;",
            "    int size_u, size_v, nil;",
            "    vector<int> pair_u, pair_v, dist;",
            "    vector<vector<int>> adjacency;",
            "",
            "    bool __bfs() {",
            "        queue<int> q;",
            "        for (int u = 0; u < size_u; u++)",
            "            if (pair_u[u] == nil)",
            "                dist[u] = 0, q.push(u);",
            "            else",
            "                dist[u] = INF;",
            "        dist[nil] = INF;",
            "        while (not q.empty()) {",
            "            int u = q.front();",
            "            q.pop();",
            "            if (dist[u] >= dist[nil])",
            "                continue;",
            "            for (int v : adjacency[u])",
            "                if (dist[pair_v[v]] == INF)",
            "                    dist[pair_v[v]] = dist[u] + 1, q.push(pair_v[v]);",
            "        }",
            "        return dist[nil] != INF;",
            "    }",
            "    bool __dfs(int u) {",
            "        if (u == nil)",
            "            return true;",
            "        for (int v : adjacency[u])",
            "            if (dist[pair_v[v]] == dist[u] + 1)",
            "                if (__dfs(pair_v[v])) {",
            "                    pair_v[v] = u, pair_u[u] = v;",
            "                    return true;",
            "                }",
            "        dist[u] = INF;",
            "        return false;",
            "    }",
            "",
            "   public:",
            "    HopcroftKarp(int u_size, int v_size) {",
            "        nil = size_u = size_v = max(u_size, v_size);",
            "        adjacency.resize(size_u + 1);",
            "        dist.resize(size_u + 1);",
            "        pair_u.resize(size_u + 1);",
            "        pair_v.resize(size_v);",
            "    }",
            "    void add_edge(int u, int v) {",
            "        adjacency[u].push_back(v);",
            "    }",
            "    int max_match() {",
            "        fill(pair_u.begin(), pair_u.end(), nil);",
            "        fill(pair_v.begin(), pair_v.end(), nil);",
            "        int res = 0;",
            "        while (__bfs())",
            "            for (int u = 0; u < size_u; u++)",
            "                if (pair_u[u] == nil && __dfs(u))",
            "                    res++;",
            "        return res;",
            "    }",
            "};            ",
        ],
        "description": "Gives the maximal matching on a bipartite graph"
    },
    "Centroid Decomposition": {
        "prefix": "$ds-centroidtree",
        "body": [
            "class CentroidTree : public Tree {",
            "    private:",
            "     vector<bool> __visited;",
            "     vector<int> __dir_parents, __subtree_size;",
            "     Tree base;",
            " ",
            "     void __dfs_centroid(int node) {",
            "         __subtree_size[node] = 1;",
            "         for (Node *next : base.list[node].adjacent)",
            "             if (!__visited[next->index] && next->index != __dir_parents[node]) {",
            "                 __dir_parents[next->index] = node;",
            "                 __dfs_centroid(next->index);",
            "                 __subtree_size[node] += __subtree_size[next->index];",
            "             }",
            "     }",
            " ",
            "     int __get_centroid(int x) {",
            "         __dir_parents[x] = 0;",
            "         __dfs_centroid(x);",
            "         int sz = __subtree_size[x];",
            "         while (true) {",
            "             pair<int, int> mx = {0, 0};",
            "             for (Node *next : base.list[x].adjacent)",
            "                 if (!__visited[next->index] && next->index != __dir_parents[x])",
            "                     mx = max(mx, {__subtree_size[next->index], next->index});",
            "             if (mx.first * 2 > sz)",
            "                 x = mx.second;",
            "             else",
            "                 return x;",
            "         }",
            "     }",
            " ",
            "     void __build_centroid(int node, Node *parent) {",
            "         node = __get_centroid(node);",
            "         list[node].parent = parent;",
            "         __visited[node] = true;",
            "         for (Node *next : base.list[node].adjacent)",
            "             if (!__visited[next->index])",
            "                 __build_centroid(next->index, &list[node]);",
            "     }",
            " ",
            "    public:",
            "     CentroidTree(Tree &tree) : Tree((int)tree.list.size()) {",
            "         __visited = vector<bool>(tree.list.size());",
            "         __subtree_size = vector<int>(tree.list.size());",
            "         __dir_parents = vector<int>(tree.list.size());",
            "         base = tree;",
            "         __build_centroid(0, nullptr);",
            "         for (auto el : list) {",
            "             if (el.parent == nullptr)",
            "                 root = &list[el.index];",
            "             else",
            "                 add_edge(el.index, el.parent->index);",
            "         }",
            "         __build(root);",
            "     }",
            " };"
        ],
        "description": "A full tree that is constructed by Centroid Decomposition on Another Tree"
    },
    "Tree Input": {
        "prefix": "$in-tree",
        "body": [
            "int n;",
            "cin >> n;",
            "Tree tree(n);",
            "for (int i = 0; i < n - 1; i++) {",
            "    int a, b;",
            "    cin >> a >> b;",
            "    tree.add_edge(a - 1, b - 1);",
            "}",
            "tree.__build();",
            "tree.__build_lca_matrix();"
        ],
        "description": "Take a tree as input (standard pair format)"
    },
    "Segment Query Tree": {
        "prefix": "$ds-segtree",
        "body": [
            "template <class Type>",
            "class SegmentTree {",
            "   protected:",
            "    vector<Type> data;",
            "    unsigned long size;",
            "    inline unsigned long parent(unsigned long i) {",
            "        return i >> 1;",
            "    }",
            "    inline unsigned long lChild(unsigned long i) {",
            "        return i << 1;",
            "    }",
            "    inline unsigned long rChild(unsigned long i) {",
            "        return i << 1 | 1;",
            "    }",
            "    inline unsigned long sibling(unsigned long i) {",
            "        return i ^ 1;",
            "    }",
            "    inline unsigned long element(unsigned long i) {",
            "        return i + size;",
            "    }",
            "    inline bool isRoot(unsigned long i) {",
            "        return i == 1;",
            "    }",
            "    inline bool islChild(unsigned long i) {",
            "        return (i & 1) == 0;",
            "    }",
            "    inline bool isrChild(unsigned long i) {",
            "        return (i & 1) != 0;",
            "    }",
            "    function<Type(Type, Type)> operation;",
            "    Type defaultValue;",
            "",
            "   public:",
            "    explicit SegmentTree(const vector<Type> &list,",
            "                         function<Type(Type, Type)> segOperation,",
            "                         Type defaultTo) {",
            "        size = (1ul << (long)ceil(log2(list.size())));",
            "        data = vector<Type>(size * 2, defaultTo);",
            "        defaultValue = defaultTo;",
            "        operation = segOperation;",
            "        for (unsigned long i = 0; i < list.size(); i++)",
            "            data[i + size] = list[i];",
            "        for (unsigned long i = size - 1; i > 0; --i)",
            "            data[i] = operation(data[lChild(i)], data[rChild(i)]);",
            "    }",
            "    void modify(unsigned long position, Type value) {",
            "        data[element(position)] = value;",
            "        for (data[position = element(position)]; !isRoot(position);",
            "             position = parent(position)) {",
            "            if (islChild(position))",
            "                data[parent(position)] =",
            "                    operation(data[position], data[sibling(position)]);",
            "            if (isrChild(position))",
            "                data[parent(position)] =",
            "                    operation(data[sibling(position)], data[position]);",
            "        }",
            "    }",
            "    Type query(unsigned long l, unsigned long r) {",
            "        Type lAccumulator = defaultValue, rAccumulator = defaultValue;",
            "        for (l = element(l), r = element(r); l < r;",
            "             l = parent(l), r = parent(r)) {",
            "            if (isrChild(l)) {",
            "                lAccumulator = operation(lAccumulator, data[l++]);",
            "            }",
            "            if (isrChild(r)) {",
            "                rAccumulator = operation(data[--r], rAccumulator);",
            "            }",
            "        }",
            "        return operation(lAccumulator, rAccumulator);",
            "    }",
            "};"
        ],
        "description": "A segment tree to provide Range Query Point Update"
    },
    "Segment Update Tree": {
        "prefix": "$ds-segupdate",
        "body": [
            "template <class Type>",
            "class SegmentUpdate {",
            "   protected:",
            "    vector<Type> data;",
            "    unsigned long size;",
            "    inline unsigned long parent(unsigned long i) {",
            "        return i >> 1;",
            "    }",
            "    inline unsigned long lChild(unsigned long i) {",
            "        return i << 1;",
            "    }",
            "    inline unsigned long rChild(unsigned long i) {",
            "        return i << 1 | 1;",
            "    }",
            "    inline unsigned long sibling(unsigned long i) {",
            "        return i ^ 1;",
            "    }",
            "    inline unsigned long element(unsigned long i) {",
            "        return i + size;",
            "    }",
            "    inline bool isRoot(unsigned long i) {",
            "        return i == 1;",
            "    }",
            "    inline bool islChild(unsigned long i) {",
            "        return (i & 1) == 0;",
            "    }",
            "    inline bool isrChild(unsigned long i) {",
            "        return (i & 1) != 0;",
            "    }",
            "    function<Type(Type, Type)> operation;",
            "    Type defaultValue;",
            "",
            "   public:",
            "    explicit SegmentUpdate(const vector<Type> &list,",
            "                           function<Type(Type, Type)> segOperation,",
            "                           Type defaultTo) {",
            "        size = (1ul << (long)ceil(log2(list.size())));",
            "        data = vector<Type>(size * 2, defaultTo);",
            "        defaultValue = defaultTo;",
            "        operation = segOperation;",
            "        for (unsigned long i = 0; i < list.size(); i++)",
            "            data[i + size] = list[i];",
            "        for (unsigned long i = size - 1; i > 0; --i)",
            "            data[i] = operation(data[lChild(i)], data[rChild(i)]);",
            "    }",
            "    void modify(unsigned long l, unsigned long r, Type value) {",
            "        for (l = element(l), r = element(r); l < r;",
            "             l = parent(l), r = parent(r)) {",
            "            if (isrChild(l)) {",
            "                data[l] = operation(data[l], value);",
            "                l++;",
            "            }",
            "            if (isrChild(r)) {",
            "                --r;",
            "                data[r] = operation(data[r], value);",
            "            }",
            "        }",
            "    }",
            "    Type query(unsigned long position) {",
            "        Type accumulator = defaultValue;",
            "        for (position = element(position);; position = parent(position)) {",
            "            accumulator = operation(accumulator, data[position]);",
            "            if (isRoot(position))",
            "                break;",
            "        }",
            "        return accumulator;",
            "    }",
            "};"
        ],
        "description": "A segment tree to allow Point Query Range Update"
    },
    "Disjoint Set Union Find - Tree": {
        "prefix": "$ds-dsu",
        "body": [
            "struct DisjointSetTree {",
            "    ll comp_count;",
            "    vector<ll> parent, comp_size;",
            "    set<ll> roots;",
            "",
            "    DisjointSetTree(int n) {",
            "        comp_count = n;",
            "        parent.resize(n);",
            "        comp_size.resize(n, 1);",
            "        iota(parent.begin(), parent.end(), 0);",
            "        for (int i = 0; i < n; i++) {",
            "            roots.insert(i);",
            "        }",
            "    }",
            "",
            "    int find(int u) {",
            "        if (parent[u] == u)",
            "            return parent[u];",
            "        return parent[u] = find(parent[u]);",
            "    }",
            "",
            "    bool merge(int u, int v) {",
            "        u = find(u), v = find(v);",
            "        if (u == v)",
            "            return false;",
            "        parent[u] = v;",
            "        comp_size[v] += comp_size[u];",
            "        comp_size[u] = 0;",
            "        roots.erase(u);",
            "        comp_count--;",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "A path compressed forest to support union operation"
    },
    "Check if Prime": {
        "prefix": "$gn-isprime",
        "body": [
            "bool is_prime(ll n) {",
            "    for (int i = 2; i <= sqrt(n); i++) {",
            "        if (n % i == 0)",
            "            return true;",
            "    }",
            "    return false;",
            "}"
        ],
        "description": "Checks if a number is prime or composite"
    },
    "Implicit Lazy Segment Tree": {
        "prefix": "$ds-implazyseg",
        "body": [
            "template <typename Type>",
            "class ImplicitSegtree {",
            "    struct Node {",
            "        Type data = 0, lazy = 0;",
            "        Node *l_ptr = nullptr, *r_ptr = nullptr;",
            "        Node *l_child() {",
            "            if (l_ptr == nullptr) {",
            "                l_ptr = new Node;",
            "                r_ptr = new Node;",
            "            }",
            "            return l_ptr;",
            "        }",
            "        Node *r_child() {",
            "            if (r_ptr == nullptr) {",
            "                l_ptr = new Node;",
            "                r_ptr = new Node;",
            "            }",
            "            return r_ptr;",
            "        }",
            "    };",
            "    int size;",
            "    Node *root;",
            "    Type _default;",
            "    function<Type(Type, Type)> _operation;",
            "    function<Type(Type, Type)> _setter;",
            "",
            "    void split(Node *node) {",
            "        node->l_child()->lazy = _setter(node->l_child()->lazy, node->lazy);",
            "        node->r_child()->lazy = _setter(node->r_child()->lazy, node->lazy);",
            "        node->l_child()->data = _setter(node->l_child()->data, node->lazy);",
            "        node->r_child()->data = _setter(node->r_child()->data, node->lazy);",
            "        node->lazy = _default;",
            "    }",
            "    void merge(Node *node) {",
            "        node->data = _operation(node->l_child()->data, node->r_child()->data);",
            "    }",
            "",
            "   public:",
            "    ImplicitSegtree(int n, const function<Type(Type, Type)> &op,",
            "                    const function<Type(Type, Type)> &set,",
            "                    const Type identity) {",
            "        for (size = 1; size < n; size <<= 1)",
            "            ;",
            "        _setter = set, _operation = op, _default = identity;",
            "        root = new Node;",
            "    }",
            "",
            "    void modify(int l, int r, Type delta, Node *node = nullptr, int x = 0,",
            "                int y = -1) {",
            "        if (node == nullptr)",
            "            node = root, y = size;",
            "        if (r <= x || l >= y)",
            "            return;",
            "        if (l <= x && y <= r) {",
            "            node->lazy = _setter(node->lazy, delta);",
            "            node->data = _setter(node->data, delta);",
            "            return;",
            "        }",
            "        split(node);",
            "        modify(l, r, delta, node->l_child(), x, (x + y) / 2);",
            "        modify(l, r, delta, node->r_child(), (x + y) / 2, y);",
            "        merge(node);",
            "    }",
            "    Type query(int l, int r, Node *node = nullptr, int x = 0, int y = -1) {",
            "        if (node == nullptr)",
            "            node = root, y = size;",
            "        if (r <= x || l >= y)",
            "            return _default;",
            "        if (l <= x && y <= r) {",
            "            return node->data;",
            "        }",
            "        split(node);",
            "        Type lres = query(l, r, node->l_child(), x, (x + y) / 2);",
            "        Type rres = query(l, r, node->r_child(), (x + y) / 2, y);",
            "        merge(node);",
            "        return _operation(lres, rres);",
            "    }",
            "};"
        ],
        "description": "An Implicit (Dynamic) Lazy Segment Tree"
    },
    "Implicit Segment Update Tree": {
        "prefix": "$ds-impsegupd",
        "body": [
            "template <typename Type>",
            "class ImplicitSegupdate {",
            "    struct Node {",
            "        Type data = 0;",
            "        Node *l_ptr = nullptr, *r_ptr = nullptr;",
            "        Node *l_child() {",
            "            if (l_ptr == nullptr) {",
            "                l_ptr = new Node;",
            "                r_ptr = new Node;",
            "            }",
            "            return l_ptr;",
            "        }",
            "        Node *r_child() {",
            "            if (r_ptr == nullptr) {",
            "                l_ptr = new Node;",
            "                r_ptr = new Node;",
            "            }",
            "            return r_ptr;",
            "        }",
            "    };",
            "    int size;",
            "    Node *root;",
            "    function<Type(Type, Type)> _setter;",
            "",
            "   public:",
            "    ImplicitSegupdate(int n, const function<Type(Type, Type)> &set) {",
            "        for (size = 1; size < n; size <<= 1)",
            "            ;",
            "        _setter = set;",
            "        root = new Node;",
            "    }",
            "",
            "    void modify(int l, int r, Type delta, Node *node = nullptr, int x = 0,",
            "                int y = -1) {",
            "        if (node == nullptr)",
            "            node = root, y = size;",
            "        if (r <= x || l >= y)",
            "            return;",
            "        if (l <= x && y <= r) {",
            "            node->data = _setter(node->data, delta);",
            "            return;",
            "        }",
            "        modify(l, r, delta, node->l_child(), x, (x + y) / 2);",
            "        modify(l, r, delta, node->r_child(), (x + y) / 2, y);",
            "    }",
            "    Type query(int p, Node *node = nullptr, int x = 0, int y = -1) {",
            "        if (node == nullptr)",
            "            node = root, y = size;",
            "        if (x == p && y == p + 1) {",
            "            return node->data;",
            "        }0",
            "        if (x <= p && p < (x + y) / 2)",
            "            return _setter(node->data,",
            "                           query(p, node->l_child(), x, (x + y) / 2));",
            "        else",
            "            return _setter(node->data,",
            "                           query(p, node->r_child(), (x + y) / 2, y));",
            "    }",
            "};"
        ],
        "description": "Implicit Segment Tree performing update operations"
    },
    "Dynamic Connectivity": {
        "prefix": "$ds-dynacon",
        "body": [
            "class DynamicConnectivity {",
            "    void __dfs(int v, int l, int r, vector<long long>& res) {",
            "        long long last_ans = answer;",
            "        int state = save_ptr;",
            "        for (auto query : tree[v])",
            "            merge(query);",
            "        if (l == r - 1)",
            "            res[l] = answer;",
            "        else {",
            "            int m = (l + r) / 2;",
            "            __dfs(v * 2 + 1, l, m, res);",
            "            __dfs(v * 2 + 2, m, r, res);",
            "        }",
            "        while (save_ptr != state)",
            "            rollback();",
            "        answer = last_ans;",
            "    };",
            "",
            "   public:",
            "    int size_nodes;",
            "    int size_query;",
            "",
            "    struct Node {",
            "        long long parent, comp_size = 1;",
            "    };",
            "    long long answer = 0;",
            "    vector<Node> data;",
            "    vector<long long*> saved_object;",
            "    vector<long long> saved_value;",
            "    int save_ptr = 0;",
            "",
            "    struct Query {",
            "        int u, v;",
            "        Query(pair<int, int> p = {0, 0}) {",
            "            u = p.first, v = p.second;",
            "        }",
            "    };",
            "    vector<vector<Query>> tree;",
            "",
            "    DynamicConnectivity(int n = 600000, int q = 300000) {",
            "        size_nodes = n;",
            "        size_query = q;",
            "        int tree_size = 1;",
            "        while (tree_size < q)",
            "            tree_size <<= 1;",
            "        data = vector<Node>(n);",
            "        tree = vector<vector<Query>>(2 * tree_size);",
            "        saved_object = vector<long long*>(4 * q);",
            "        saved_value = vector<long long>(4 * q);",
            "        for (int i = 0; i < n; i++) {",
            "            data[i].parent = i;",
            "        }",
            "        // Storing the initial answer",
            "        answer = n;",
            "    }",
            "",
            "    void change(long long& x, long long y) {",
            "        saved_object[save_ptr] = &x;",
            "        saved_value[save_ptr] = x;",
            "        x = y;",
            "        save_ptr++;",
            "    }",
            "",
            "    void rollback() {",
            "        save_ptr--;",
            "        (*saved_object[save_ptr]) = saved_value[save_ptr];",
            "    }",
            "",
            "    int find(int x) {",
            "        if (data[x].parent == x)",
            "            return x;",
            "        return find(data[x].parent);",
            "    }",
            "",
            "    void merge(const Query& q) {",
            "        int x = find(q.u);",
            "        int y = find(q.v);",
            "        if (x == y)",
            "            return;",
            "        if (data[x].comp_size < data[y].comp_size)",
            "            swap(x, y);",
            "        change(data[y].parent, x);",
            "        change(data[x].comp_size, data[x].comp_size + data[y].comp_size);",
            "        // Changing the Answer on query",
            "        change(answer, answer - 1);",
            "    }",
            "",
            "    void add(int l, int r, Query edge, int node = 0, int x = 0, int y = -1) {",
            "        if (y == -1)",
            "            y = size_query;",
            "        if (l >= r)",
            "            return;",
            "        if (l == x && r == y)",
            "            tree[node].push_back(edge);",
            "        else {",
            "            int m = (x + y) / 2;",
            "            add(l, min(r, m), edge, node * 2 + 1, x, m);",
            "            add(max(m, l), r, edge, node * 2 + 2, m, y);",
            "        }",
            "    }",
            "",
            "    vector<long long> solve(int v = 0, int l = 0, int r = -1) {",
            "        if (r == -1)",
            "            r = size_query;",
            "        vector<long long> vec(size_query);",
            "        if (size_query > 0)",
            "            __dfs(v, l, r, vec);",
            "        return vec;",
            "    }",
            "",
            "    DynamicConnectivity(int n, vector<Query> queries)",
            "        : DynamicConnectivity(n, queries.size()) {",
            "        map<pair<int, int>, int> last;",
            "        for (int i = 0; i < size_query; i++) {",
            "            pair<int, int> p(queries[i].u, queries[i].v);",
            "            if (last.count(p)) {",
            "                add(last[p], i, queries[i]);",
            "                last.erase(p);",
            "            } else {",
            "                last[p] = i;",
            "            }",
            "        }",
            "        for (auto x : last)",
            "            add(x.second, size_query, x.first);",
            "    }",
            "};"
        ],
        "description": "Disjoint Set Union Find with delete operations on the graph supported"
    },
    "File Input/Output": {
        "prefix": "$freopen",
        "body": [
            "freopen(\"$1.in\", \"r\", stdin);",
            "freopen(\"$1.out\", \"w\", stdout);"
        ],
        "description": "Redirect all input/output to and from files"
    },
    "Strongly Connected Components": {
        "prefix": "$ds-scc",
        "body": [
            "struct DirectedGraph {",
            "    int size, curr;",
            "    vector<vector<int>> adjacent_f, adjacent_r, comp_nodes;",
            "    vector<int> order, comp;",
            "    vector<bool> visited;",
            "",
            "    DirectedGraph(int n) {",
            "        size = n;",
            "        order.resize(size);",
            "        adjacent_f.resize(size);",
            "    }",
            "    void add_edge(int v1, int v2) {",
            "        adjacent_f[v1].push_back(v2);",
            "        adjacent_r[v2].push_back(v1);",
            "    }",
            "    void _scc_dfs1(int u) {",
            "        visited[u] = 1;",
            "        for (auto w : adjacent_f[u])",
            "            if (!visited[w])",
            "                _scc_dfs1(w);",
            "        order.push_back(u);",
            "    }",
            "    void _scc_dfs2(int u) {",
            "        visited[u] = 1;",
            "        comp[u] = curr;",
            "        comp_nodes[curr].push_back(u);",
            "        for (auto w : adjacent_r[u])",
            "            if (!visited[w])",
            "                _scc_dfs2(w);",
            "    }",
            "    void stongly_connected_components() {",
            "        fill(visited.begin(), visited.end(), false);",
            "        order.clear();",
            "        for (int i = 0; i < size; i++)",
            "            if (!visited[i])",
            "                _scc_dfs1(i);",
            "        fill(visited.begin(), visited.end(), false);",
            "        reverse(order.begin(), order.end());",
            "        curr = 0;",
            "        for (auto u : order)",
            "            if (!visited[u])",
            "                comp_nodes[++curr].clear(), _scc_dfs2(u);",
            "    }",
            "};",
            "",
            "struct Satisfiability : DirectedGraph {",
            "    vector<bool> val;",
            "    Satisfiability(int size) : DirectedGraph(2 * size) {",
            "        val = vector<bool>(size, false);",
            "    }",
            "",
            "    bool solvable(int vars) {",
            "        stongly_connected_components();",
            "        for (int i = 0; i < vars; i++)",
            "            if (comp[var(i)] == comp[NOT(var(i))])",
            "                return false;",
            "        return true;",
            "    }",
            "    vector<bool> solve() {",
            "        fill(val.begin(), val.end(), 0);",
            "        for (int i = 1; i <= curr; i++)",
            "            for (auto it : comp_nodes[i]) {",
            "                int u = it >> 1;",
            "                if (val[u])",
            "                    continue;",
            "                val[u] = (it & 1 ? +1 : -1);",
            "            }",
            "        return val;",
            "    }",
            "    int var(int x) {",
            "        return x << 1;",
            "    }",
            "    int NOT(int x) {",
            "        return x ^ 1;",
            "    }",
            "    void add_imp(int v1, int v2) {",
            "        add_edge(v1, v2);",
            "        add_edge(1 ^ v2, 1 ^ v1);",
            "    }",
            "    void add_equiv(int v1, int v2) {",
            "        add_imp(v1, v2);",
            "        add_imp(v2, v1);",
            "    }",
            "    void add_or(int v1, int v2) {",
            "        add_edge(1 ^ v1, v2);",
            "        add_edge(1 ^ v2, v1);",
            "    }",
            "    void add_xor(int v1, int v2) {",
            "        add_or(v1, v2);",
            "        add_or(1 ^ v1, 1 ^ v2);",
            "    }",
            "    void add_true(int v1) {",
            "        add_edge(1 ^ v1, v1);",
            "    }",
            "    void add_and(int v1, int v2) {",
            "        add_true(v1);",
            "        add_true(v2);",
            "    }",
            "};"
        ],
        "description": "2-SAT and Kosaraju's algorithm to find strongly connected components"
    },
    "Palindromic Tree": {
        "prefix": "$ds-palindromictree",
        "body": [
            "struct PalindromicTree {",
            "    const static long long MAXN = 100000;",
            "    struct Node {",
            "        int start, end;",
            "        int length;",
            "        int insert_edge[26];",
            "        int suffix_edge;",
            "    };",
            "    Node root1, root2;",
            "    Node tree[MAXN];",
            "    int curr_node, ptr, size;",
            "    string s;",
            "",
            "    void insert(int idx) {",
            "        int tmp = curr_node;",
            "        while (true) {",
            "            int curLength = tree[tmp].length;",
            "            if (idx - curLength >= 1 and s[idx] == s[idx - curLength - 1])",
            "                break;",
            "            tmp = tree[tmp].suffix_edge;",
            "        }",
            "        if (tree[tmp].insert_edge[s[idx] - 'a'] != 0) {",
            "            curr_node = tree[tmp].insert_edge[s[idx] - 'a'];",
            "            return;",
            "        }",
            "        ptr++;",
            "        tree[tmp].insert_edge[s[idx] - 'a'] = ptr;",
            "        tree[ptr].length = tree[tmp].length + 2;",
            "        tree[ptr].end = idx;",
            "        tree[ptr].start = idx - tree[ptr].length + 1;",
            "        tmp = tree[tmp].suffix_edge;",
            "        curr_node = ptr;",
            "        if (tree[curr_node].length == 1) {",
            "            tree[curr_node].suffix_edge = 2;",
            "            return;",
            "        }",
            "        while (true) {",
            "            int cur_length = tree[tmp].length;",
            "            if (idx - cur_length >= 1 and s[idx] == s[idx - cur_length - 1])",
            "                break;",
            "            tmp = tree[tmp].suffix_edge;",
            "        }",
            "        tree[curr_node].suffix_edge = tree[tmp].insert_edge[s[idx] - 'a'];",
            "    }",
            "    PalindromicTree(string st) {",
            "        root1.length = -1, root1.suffix_edge = 1, root2.length = 0,",
            "        root2.suffix_edge = 1, tree[1] = root1, tree[2] = root2, ptr = 2;",
            "        curr_node = 1, s = st, size = st.size();",
            "        for (int i = 0; i < size; i++)",
            "            insert(i);",
            "    }",
            "    vpl get_palindromes() {",
            "        vpl res(ptr - 2);",
            "        for (int i = 3; i <= ptr; i++)",
            "            res[i - 2] = {tree[i].start, tree[i].end};",
            "        return res;",
            "    }",
            "};",
        ],
        "description": "Palindromic Tree to find all palindromes in O(n)"
    },
    "Mobius Seive (Linear)": {
        "prefix": "$al-mobius",
        "body": [
            "class Multiplicative {",
            "    // This is the definition for PHI",
            "    #define fn_prime_values(prime) (prime - 1)",
            "    #define fn_non_coprime(num, prime) (fn[num] * prime)",
            "    public:",
            "    ll size; vll fn, primes, lowest_prime_factor;",
            "    Multiplicative(ll size) {",
            "        size = size;",
            "        lowest_prime_factor = vector<ll>(size, 0);",
            "        fn = vector<ll>(size, 0);",
            "        // https://stackoverflow.com/questions/34260399 - linear sieve",
            "        for (ll i = 2; i < size; i++)",
            "            lowest_prime_factor[i] = i;",
            "        // put any specific initialization code here like - multiplicative_fn[1] = 1;",
            "        for (ll i = 2; i < size; i++) {",
            "            if (lowest_prime_factor[i] == i) { fn[i] = fn_prime_values(i); primes.push_back(i); }",
            "            for (auto p : primes) {",
            "                ll ith_multiple = i * p;",
            "                if (ith_multiple >= size) break;",
            "                lowest_prime_factor[ith_multiple] = min(lowest_prime_factor[i], p);",
            "                if (i % p) { fn[ith_multiple] = fn[i] * fn[p]; } ",
            "                else { fn[ith_multiple] = fn_non_coprime(i, p); break; }",
            "            }",
            "        }",
            "    }",
            "};"
        ],
        "description": "Construct using a linear seive the mobius function"
    },
    "Merge Sort Tree": {
        "prefix": "$ds-mergesorttree",
        "body": [
            "template <typename Type>",
            "struct MergeSortTree {",
            "    int size;",
            "    vector<Type> data;",
            "    vector<vector<int>> tree_idx;",
            "    vector<vector<Type>> tree_val;",
            "    long long inversions;",
            "",
            "    template <typename DataType>",
            "    vector<DataType> merge(const vector<DataType> &arr1,",
            "                           const vector<DataType> &arr2) {",
            "        int n = arr1.size(), m = arr2.size();",
            "        vector<DataType> result;",
            "        result.reserve(n + m);",
            "        for (int x = 0, y = 0; x < n || y < m;) {",
            "            if (x < n && (y >= m || arr1[x] <= arr2[y]))",
            "                result.push_back(arr1[x++]);",
            "            else",
            "                result.push_back(arr2[y++]), inversions += n - x;",
            "        }",
            "        return move(result);",
            "    }",
            "    int order_fn(const Type &value, const vector<Type> &arr) {",
            "        return lower_bound(arr.begin(), arr.end(), value) - arr.begin();",
            "    }",
            "    explicit MergeSortTree(const vector<Type> &list) {",
            "        for (size = 1; size < list.size(); size *= 2)",
            "            ;",
            "        // Make a tree based on the values",
            "        tree_val.resize(2 * size);",
            "        data = vector<Type>(list);",
            "        for (int i = 0; i < list.size(); i++)",
            "            tree_val[i + size].push_back(i);",
            "        for (int i = size - 1; i > 0; --i)",
            "            tree_val[i] = merge<Type>(tree_val[i << 1], tree_val[i << 1 | 1]);",
            "        // Make a tree based on the indices",
            "        tree_idx.resize(2 * size);",
            "        vector<pair<Type, int>> convert(list.size());",
            "        for (int i = 0; i < list.size(); i++)",
            "            convert[i].first = list[i], convert[i].second = i;",
            "        sort(convert.begin(), convert.end());",
            "        for (int i = 0; i < list.size(); i++)",
            "            tree_idx[i + size].push_back(convert[i].second);",
            "        for (int i = size - 1; i > 0; --i)",
            "            tree_idx[i] = merge<int>(tree_idx[i << 1], tree_idx[i << 1 | 1]);",
            "    }",
            "    int order_of_key(int l, int r, Type value) {",
            "        int result = 0;",
            "        for (l = l + size, r = r + size; l < r; l >>= 1, r >>= 1) {",
            "            if (l & 1)",
            "                result += order_fn(value, tree_val[l++]);",
            "            if (r & 1)",
            "                result += order_fn(value, tree_val[--r]);",
            "        }",
            "        return result;",
            "    }",
            "    int key_of_order(int l, int r, int order, int node = 0, int x = 0,",
            "                     int y = -1) {",
            "        if (y == -1)",
            "            y = size;",
            "        if (x + 1 == y)",
            "            return tree_idx[node][0];",
            "        int m = (upper_bound(tree_idx[2 * node].begin(),",
            "                             tree_idx[2 * node].end(), r - 1) -",
            "                 tree_idx[2 * node].begin()) -",
            "                (lower_bound(tree_idx[2 * node].begin(),",
            "                             tree_idx[2 * node].end(), l) -",
            "                 tree_idx[2 * node].begin());",
            "        if (m >= order)",
            "            return key_of_order(l, r, order, node << 1, x, (x + y) / 2);",
            "        else",
            "            return key_of_order(l, r, order - m, node << 1 | 1, (x + y) / 2, y);",
            "    }",
            "};"
        ],
        "description": "Range Order Statistics using a Merge Sort Tree"
    },
    "Huffman Encoding Tree": {
        "prefix": "$al-huffman",
        "body": [
            "struct HuffmanTree {",
            "    vll prob;",
            "    vector<pair<int, bool>> parent;",
            "    vector<int> depth;",
            "    ll size, total_prob;",
            "",
            "    HuffmanTree(const vll &p) {",
            "        // Initialize everything",
            "        prob = vll(p);",
            "        total_prob = accumulate(prob.begin(), prob.end(), 0);",
            "        size = p.size();",
            "        parent = vector<pair<int, bool>>(size * 2, {-1, false});",
            "        depth = vector<int>(size);",
            "        // Get the parents of each node by greedy combination",
            "        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> q;",
            "        for (int i = 0; i < size; i++)",
            "            q.emplace(prob[i], i);",
            "        int next_free_node = size;",
            "        for (int i = 0; q.size() >= 2; i++) {",
            "            pair<int, int> top1 = q.top();",
            "            q.pop();",
            "            pair<int, int> top2 = q.top();",
            "            q.pop();",
            "            parent[top1.second] = {next_free_node, false};",
            "            parent[top2.second] = {next_free_node, true};",
            "            q.emplace(top1.first + top2.first, next_free_node);",
            "            next_free_node++;",
            "        }",
            "        parent.resize(next_free_node);",
            "        // Get all the children",
            "        vector<pair<int, int>> children(2 * size, {-1, -1});",
            "        for (int i = 0; i < 2 * size; i++) {",
            "            if (parent[i].first != -1) {",
            "                if (children[parent[i].first].first == -1)",
            "                    children[parent[i].first].first = i;",
            "                else if (children[parent[i].first].second == -1)",
            "                    children[parent[i].first].second = i;",
            "            }",
            "        }",
            "        // Compute the depths using a dfs",
            "        stack<int> dfs;",
            "        dfs.push(q.top().second);",
            "        depth[q.top().second] = 0;",
            "        while (!dfs.empty()) {",
            "            ll top = dfs.top();",
            "            dfs.pop();",
            "            if (children[top].first != -1) {",
            "                depth[children[top].first] = depth[top] + 1;",
            "                dfs.push(children[top].first);",
            "            }",
            "            if (children[top].second != -1) {",
            "                depth[children[top].second] = depth[top] + 1;",
            "                dfs.push(children[top].second);",
            "            }",
            "        }",
            "    }",
            "",
            "    string get_string(int letter) {",
            "        string st;",
            "        for (int cur = letter; letter != -1; letter = parent[letter].first)",
            "            st += (parent[letter].first ? \"0\" : \"1\");",
            "        return st;",
            "    }",
            "",
            "    static ll encoding_length(const vll &p) {",
            "        priority_queue<ll, vector<ll>, greater<>> q;",
            "        for (auto el : p)",
            "            q.push(el);",
            "        ll ans = 0;",
            "        while (q.size() >= 2) {",
            "            ll top1 = q.top();",
            "            q.pop();",
            "            ll top2 = q.top();",
            "            q.pop();",
            "            ans += top1 + top2;",
            "            q.push(top1 + top2);",
            "        }",
            "        return ans;",
            "    }",
            "};",
        ],
        "description": "Constructs the Huffman Encoding Tree and gives encoded strings"
    },
    "Matrix": {
        "prefix": "$gn-matrix",
        "body": [
            "template <class Type>",
            "class Matrix {",
            "     public:",
            "        vector<vector<Type>> mat;",
            "        unsigned long m, n = 0;",
            "",
            "        Matrix(unsigned long size, bool unity = true) {",
            "                mat = vector<vector<Type>>(size, vector<Type>(size, 0));",
            "                m = size;",
            "                n = size;",
            "                if (unity)",
            "                        for (int i = 0; i < size; i++)",
            "                                mat[i][i] = 1;",
            "        }",
            "        Matrix(vector<vector<Type>> mat) {",
            "                this->mat = mat;",
            "                m = this->mat.size();",
            "                n = (this->mat.size() > 0 ? this->mat[0].size() : 0);",
            "        }",
            "        friend Matrix<Type> operator*(Matrix<Type> a, Matrix<Type> b) {",
            "                assert(a.m == b.n);",
            "                Matrix res(vector<vector<long long>>(a.n, vector<long long>(b.m, 0)));",
            "                for (int i = 0; i < a.n; i++) {",
            "                        for (int j = 0; j < b.m; j++) {",
            "                                for (int k = 0; k < a.m; k++) {",
            "                                        res.mat[i][j] =",
            "                                                (res.mat[i][j] + (a.mat[i][k] * b.mat[k][j]));",
            "                                }",
            "                        }",
            "                }",
            "                return res;",
            "        }",
            "        friend vector<Type> operator*(Matrix<Type> a, vector<Type> b) {",
            "                assert(a.m == b.size());",
            "                vector<Type> res(a.n, 0);",
            "                for (int i = 0; i < a.n; i++) {",
            "                        for (int j = 0; j < a.m; j++) {",
            "                                res[i] = (res[i] + (a.mat[i][j] * b[j]));",
            "                        }",
            "                }",
            "                return res;",
            "        }",
            "        friend Matrix<Type> operator^(Matrix<Type> a, long long b) {",
            "                assert(a.n == a.m);",
            "                Matrix<Type> cumulative = a, result = Matrix<long long>(a.n);",
            "                for (; b > 0; b /= 2) {",
            "                        if (b % 2 == 1)",
            "                                result = (result * cumulative);",
            "                        cumulative = (cumulative * cumulative);",
            "                }",
            "                return result;",
            "        }",
            "};",
        ],
        "description": "Matrix Exponentiation and Multiplication."
    },
    "Closest Pair of Points - Geometry": {
        "prefix": "$al-closestpair",
        "body": [
            "double closest_pair(const vpl &pt, int n) {",
            "    double best = FLT_MAX;",
            "    set<pll> box;",
            "    box.insert(pt[0]);",
            "    int left = 0;",
            "    for (int i = 1; i < n; ++i) {",
            "        while (left < i && pt[i].second - pt[left].second > sqrt(best))",
            "            box.erase(pt[left++]);",
            "        ll cnt = 0;",
            "        for (auto it = box.lower_bound(",
            "                 {pt[i].first - sqrt(best), pt[i].second - sqrt(best)});",
            "             it != box.end() && pt[i].first + sqrt(best) >= it->first; it++) {",
            "            cnt++;",
            "            best = min(best, (pow(pt[i].first - it->first, 2.0) +",
            "                              pow(pt[i].second - it->second, 2.0)));",
            "        }",
            "        box.insert(pt[i]);",
            "    }",
            "    return best;",
            "}"
        ],
        "description": "Find the Closest pair of points on a 2-D plane using Sweep Line"
    },
    "Trie": {
        "prefix": "$ds-trie",
        "body": [
            "class Trie {",
            "    struct Node {",
            "        const static int CHARSET_SIZE = 26;",
            "        vector<Node *> next = vector<Node *>(CHARSET_SIZE);",
            "        int depth = 0, word_count = 0;",
            "    };",
            "    inline int letter_fn(char c) {",
            "        return c - 'a';",
            "    };",
            "",
            "    Node *root = new Node;",
            "    void insert(string word, Node *node = nullptr, int position = 0) {",
            "        if (node == nullptr)",
            "            node = root, word += \"$\";",
            "        if (position >= word.size())",
            "            return;",
            "        if (node->next[letter_fn(word[position])] == nullptr) {",
            "            node->next[letter_fn(word[position])] = new Node;",
            "            node->next[letter_fn(word[position])]->depth = node->depth + 1;",
            "        }",
            "        node->word_count++;",
            "        insert(word, node->next[letter_fn(word[position])], position + 1);",
            "    }",
            "    int count(string word, Node *node = nullptr, int position = 0) {",
            "        // NOTE: Remember to add $ at the end for exact search",
            "        if (node == nullptr)",
            "            node = root, word += \"$\";",
            "        if (position == word.size())",
            "            return node->word_count;",
            "        if (node->next[word[position] - 'a'] == nullptr)",
            "            return 0;",
            "        return count(word, node->next[letter_fn(word[position])], position + 1);",
            "    }",
            "};",
        ],
        "description": "Insert and Search words in a trie"
    }
}